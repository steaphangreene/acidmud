// *************************************************************************
//  This file is part of AcidMUD by Steaphan Greene
//
//  Copyright 1999-2022 Steaphan Greene <steaphan@gmail.com>
//
//  AcidMUD is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 3 of the License, or
//  (at your option) any later version.
//
//  AcidMUD is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with AcidMUD (see the file named "COPYING");
//  If not, see <http://www.gnu.org/licenses/>.
//
// *************************************************************************

#include "commands.hpp"
#include "object.hpp"
#include "utils.hpp"

// Autogenerated from tba/socials.new
static std::array<std::array<std::u8string, 13>, NUM_SOCIALS> socials = {{
    COM_SOCIAL,
}};

int handle_social_command(
    Object* body,
    std::shared_ptr<Mind>& mind,
    int cnum,
    const std::u8string_view& args,
    int stealth_t,
    int stealth_s) {
  if (!mind)
    return 0;

  const auto snum = cnum - COM_MAX_STANDARD;
  Object* targ = nullptr;
  if (body && body->Parent()) {
    std::u8string youmes = socials[snum][0];
    std::u8string outmes = socials[snum][1];
    std::u8string targmes = u8"";
    if (!args.empty()) {
      targ = body->PickObject(args, LOC_NEARBY | LOC_SELF | LOC_INTERNAL);
      if (!targ) {
        youmes = socials[snum][5];
        outmes = u8"";
      } else if (targ == body) {
        youmes = socials[snum][6];
        outmes = socials[snum][7];
      } else {
        youmes = socials[snum][2];
        outmes = socials[snum][3];
        targmes = socials[snum][4];
      }
    }
    if (outmes[0]) {
      replace_all(outmes, u8"$e", body->Pron());
      replace_all(outmes, u8"$m", body->Obje());
      replace_all(outmes, u8"$s", body->Poss());
      replace_all(outmes, u8"$n", body->Noun(1));
      if (targ) {
        replace_all(outmes, u8"$E", targ->Pron());
        replace_all(outmes, u8"$M", targ->Obje());
        replace_all(outmes, u8"$S", targ->Poss());
        replace_all(outmes, u8"$N", targ->Noun(1));
        replace_all(outmes, u8"$t", targ->Noun(1));
        replace_all(outmes, u8"$p", targ->Noun(1));
      }
      outmes[0] = ascii_toupper(outmes[0]);
      outmes += u8"\n";
    }
    if (youmes[0]) {
      replace_all(youmes, u8"$e", body->Pron());
      replace_all(youmes, u8"$m", body->Obje());
      replace_all(youmes, u8"$s", body->Poss());
      replace_all(youmes, u8"$n", body->Noun(1));
      if (targ) {
        replace_all(youmes, u8"$E", targ->Pron());
        replace_all(youmes, u8"$M", targ->Obje());
        replace_all(youmes, u8"$S", targ->Poss());
        replace_all(youmes, u8"$N", targ->Noun(1));
        replace_all(youmes, u8"$t", targ->Noun(1));
        replace_all(youmes, u8"$p", targ->Noun(1));
      }
      youmes[0] = ascii_toupper(youmes[0]);
      youmes += u8"\n";
    }
    if (targ) {
      replace_all(targmes, u8"$e", body->Pron());
      replace_all(targmes, u8"$m", body->Obje());
      replace_all(targmes, u8"$s", body->Poss());
      replace_all(targmes, u8"$n", body->Noun(1));
      if (targ) {
        replace_all(targmes, u8"$E", targ->Pron());
        replace_all(targmes, u8"$M", targ->Obje());
        replace_all(targmes, u8"$S", targ->Poss());
        replace_all(targmes, u8"$N", targ->Noun(1));
        replace_all(targmes, u8"$t", targ->Noun(1));
        replace_all(targmes, u8"$p", targ->Noun(1));
      }
      targmes[0] = ascii_toupper(targmes[0]);
      targmes += u8"\n";
      targ->Send(0, 0, targmes);
      targ->Deafen(true);
    }
    body->Parent()->SendOut(0, 0, outmes, youmes, body, targ);
    if (targ)
      targ->Deafen(false);
  }
  return 0;
}
